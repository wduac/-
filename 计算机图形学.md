三维转换之前的知识点:
https://blog.csdn.net/qq_36459481/article/details/87515998
# 闫老师补充
## 如何判断一个点在不在三角形内
ABC和点P 判断 CP在不在AB一边，先叉乘得到法向量，在点乘，如果角度在90度以内，说明同一边；如果三条边都满足这个关系，那么说明是正确的
## 采样遇到的artifact：锯齿,摩尔纹，车轮效应(时间采样上的问题)
### 抗锯齿(反走样)
对图形做一个滤波（模糊处理）,再采样
注意：先采样，再滤波是不行的(blurred alias)

### MSAA
将每个像素划分成更小的N个像素(4个)，根据每个大像素内部小像素的覆盖率，来给像素赋值，覆盖率越高，像素值越大。
http://www.lotpc.com/yjzs/8276.html

### 画家算法和Z-buffer算法
画家：从后往前依次画每个物体(依次光栅化),排序n个三角形，具体实现看下面  
Z-buffer:得到每个像素点对应属于的物体,利用z-buffer,可以根据两端点深度然后插值  
Z-buffer：o(n)，因为实际上并没有排序，而是一个一个像素点求zmin，非常重要，几乎所有GPUs的硬件都实现了这个深度测试算法  
如果用到了MSAA，那么不是对每个像素进行深度测试，而是对每个分割的小像素点进行深度测试  

### Lambertian漫反射公式
Ld = kd*(1/d^2)* max(0,l) Kd是一个系数，因为每个物体吸收部分颜色的光，所以这个系数负责表示反射的颜色  
 
### shading方式
1.flat shading: 每个三角形求一个法向量来着色(对每个face进行着色)
2. Gouraud shading: 每个顶点进行着色，通过三角顶点进行插值
3. Phong shading: 对每个三角形的法向量进行插值，对每个像素点进行着色
当我们几何mesh number增加的时候 flating shading越来越像后面两个shading，所以不需要逐像素的着色

vertex着色方法：每个点有n个相邻的面，对每个面求平均(加权平均或加系数的平均)
Phong shading：Barycentric interpolation，记得最后归一化，因为每个法线应该是单位向量

### 实时渲染管线 real-time rendering pipeline
![渲染管线流程](https://github.com/wduac/-/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/images/K%5B~9KQEP_Y%60PJE99Q)%5D%60%7DAH.png)

### 插值
ABC三角形内一点P=alphaA+beteB+gammaC   alpha，beta,gamma可以根据三个小三角形占总三角形面积的比例来算
对于每个screen里的像素点，如果要求三维数据，应该找到投影前的3d空间坐标，然后对三维空间作插值求depth，再对应到二维空间中

### 纹理贴图
如果纹理特别小，可能多个像素点对应一个texel  解决方法：在纹理中双线性插值，
进阶插值方法：bicubic方法 但是计算量更大

如果纹理特别大：走样问题严重   
方法：1.超采样：但是消耗特别严重，不适合
2. range query(范围查询):这里是做平均值  
#### Mipmap!!!: 允许(快速、近似、方形)范围查询  Mip hierarchy：通过一个纹理生成不同分辨率的纹理(类似于CV的金字塔)
每次长宽变为1/2 实际储存量只多了1/3 
每个像素点，先找到在mipmap第几层，然后再算对应点  
如果层数D=1.8是小数，可以现在D=1和D=2双线性插值算对应值，再层与层之间进行线性插值计算  Trilinear interpolation   
缺点：特别远的地方，overblur 因为对应的D层数太深了，对应到mipmap里的都是正方形，而实际其实是长方形
解决方法之一： Anisotropic filtering各项性过滤 RIPMAP 对宽和高分别放缩，而mipmap是宽高同时放缩，更general一些，多了不均匀的压缩  
解决方法之二： EWA filtering

### 纹理的应用：本质 range query+map
#### 环境光：环境光以纹理形式贴图 存储环境光方法：放一个球，然后展开球得到球面，即是环境的texture map 这种方法叫spherical environment map
球形map问题是：球顶会出现扭曲   
解决方法：cubemap 一个立方体套住一个球，光照信息存在六个square texture map里
#### 纹理可以定义normal/height map  -> affect shading
定义相对高度或者normal向量
凹凸贴图,法线贴图：改变计算的normal，但没有实际改变"fake the geometry details"
凹凸贴图：改变高度，使扰动法线方向
displacement mapping 位移贴图：实际移动了vertex 结果更好，但是要求模型三角形足够细




# 图元扫描算法
## 1 直线的画法  链接：https://www.cnblogs.com/mangoyuan/p/6576145.html
DDA把算法效率提高到每步只做一个加法  
中点画线算法进一步将效率提高到每一步只做一个整数加法  （）
bresenham整数运算，速度快;精度高;乘2可用移位运算，适于硬件实现
### 1.1 数值微分(Digital Differential Analyzer)算法

已知过端点 P0(x0, y0)，P1(x1, y1) 的直线段 L(P0, P1)；直线斜率为 k = (y1 - y0) / (x1 - x0)。<br/>	
于是 yi+1 = kxi+1 + b。<br/>	
于是，x每增加1，y就增加k。画点的时候还需要判断 int(y+0.5) 向下取整。<br/>	

### 1.2 中点画线法
### 1.3 Bresenham画线算法

## 2 圆弧扫描方法
### 2.1 和中心点算法类似，计算d 然后判断上下点取值  
### 2.2 bresenham算法

## 3 椭圆扫描算法(类似增量算法)
 
## 4 多边形
表示多边形：不只需要边界像素集，还需要内部点集
### x扫描线算法:
#### 原理
1.得到多边形占有的最大扫描边数，得到多边形顶点的最大和最小值  
2.从y=ymin到y=ymax，每次用一条扫描线进行填充  
3.对一条扫描线填充的过程可以分为四个步骤：a.求交  b.排序  c.交点配对  d.区间填色  
问题：1.两条边交于同一点，算几个顶点  答：交点个数=构成这个顶点的两条边位于扫描线上方的条数  
     2.每个像素点看成一个圆，四等分，然后左闭右开，下闭上开  
可以改进的地方：1.对于某一条扫描线,不需要与所有的边相交，只用找到有效边
               2.可以用增量计算的方法算出交点(从上到下扫描，y每一次变化1)
               3.不用每次都排序，当边变成无效边的时候删除，重新排序的时机：有新边的加入  
#### 算法实现  
边表：从y=1 到 y=10共十个桶，把每次出现的边放入桶中      
新边：x ymax 1/k next（每条新边对应一个结点）    新边排序原则：交点递增、交点相同，增量递增  
为了实现 交点个数=构成这个顶点的两条边位于扫描线上方的条数 把新边的ymax减1，相当于这个ymax点没有与该新边的直线相交  
有效边表：存储有效边的表，每次x扫描一次，每个边的x就做增量计算，并且删除边和加入新边
优点：采用增量计算进行交点计算，且仅仅新边加入时候排序
缺点：桶表、链表的维护开销

### 边缘填充算法、栅栏填充算法和边标志算法
边标志算法：打标记，填充，初始是假，遇到标记点取反，真的时候填充  
优点：每个像素仅访问一次，避免了对帧缓存中大量元素的多次赋值，但仍需逐条扫描线地对帧缓存中的元素进行搜索和比较   
当用软件实现时候，和y向连贯性算法相当，但是硬件实现后速度提升很快  

## 5 区域填充
内界表现法和内点表现法  对应的边界填充(边界表示)和泛填充算法(内点表示)  
### 种子填充思想：先取任意内点为种子，开始填充
#### 边界填充:（已经有了边界点集合）
   4-连通边界算法：种子进栈  
   重复步骤：1. 栈顶像素出栈 2. 将出栈像素置成填充色 3.检查出栈像素的4连接点，若其中某个不是边界且未置色，则将该像素入栈  
#### 泛填充：
   前面步骤一样，第三步改为：若其中某个像素点是给定内部点的颜色且未置成新的填充色，则将该像素入栈  
#### 分析和改进
1.8连通边界算法不能填充4连接边界算法，因为会有点出边界，然后扩散出去  
2.8连接泛填充算法可以填充，因为外界的点没有内部点颜色，所以不会入栈，也就不会扩散出去  
3.每次种子只把水平部分相同的种子入栈，一行一行的来填充入栈，这样就不会有重复入栈的像素个数，提高了算法的效率  

## 6.线段的属性
通过频率插入一段空白，来变成虚线     像素模板：一段模板(包含直线和虚线)，需要根据线段角度来调整模板，不然空白可能有时很多，有时很小
线刷子：根据斜率，有垂直线刷子和水平线刷子   这样端点会不自然，一般会加个线帽，使更自然   但折现有时候会不自然
方刷子： 也分斜率  和先刷字相比：1.不需要改变方向 2.比实际线宽粗  3.自带一个帽子

## 7.走样
e.g. 微小物体的忽略，比如线条在两个像素点中间的时候，两边都不表示（根本原因是光栅化后，颜色变成离散量）
### 走样方法：
1. 提高分辨率
2. 过取样，或过滤波：高分辨率下取样计算，对几个像素属性进行平均，生成低分辨率下的像素属性 e.g.过取样例子：重叠过取样 假设显示分辨率是m x n，则将显示窗口分为(2m+1)x(2n+1)个子像素 最后加权除以9  
3. 前滤波，区域取样：根据图形在像素点上的覆盖率来算：根据斜率和起点计算直线段和像素相交面积   
e.g. 1.将屏幕像素分割成n个更小的子像素  2.计算中心落在直线段内的子像素的个数m   3. m/n为线段与像素相交区域面积的近似值
e.g. 加权区域取样 扩展：高斯滤波   
特点： a.理想直线的像素将被分配更多的灰度值    
       b. 相邻两个像素的滤波器相交，有利于缩小直线条上相邻像素的灰度查  
       
# 造型技术
## 样条： 通过一组特定点集而生成平滑曲线的柔性带
样条曲线：指由多项式曲线段连接而成的曲线，在每段的边界处满足特定的连续性条件  
样条曲面：可以使用两组样条曲线进行描述。  

### 插值和逼进样条：给定一组称为控制点的坐标点，可以得到一条样条曲线
插值样条曲线：当选取的多样式使得曲线通过多个控制点  
逼进样条曲线：部分或者全部控制点不在生成的去县上   

凸壳：包含一组控制点的凸多边形边界，样条以凸壳为界，保证平滑而不是不稳定的摆动着沿控制点前进。  
凸壳也给出了所设计曲线或曲面的坐标范围，因而它在裁剪和观察程序中十分有用  

### 参数连续性：
0阶：曲线在边界点相交   1阶：在边界点一阶导相等  N阶：n阶导相等  

### 实例：bazier曲线和曲面
在给定多项式的阶和控制点位置后，给出一条具体的样条表达式有三个等价方法： 
1.列出一组加在样条上的边界条件  
2.列出描述样条特征的行列式   e.g. x[u]=U.C 其中U是参数U的幂次行矩阵，C是系数列矩阵 x(u)=U*Mspline*Mgeom
3.列出一组混合函数或基函数  X(u)=sigma(Gk*BFk(u)) Gk是约束参数，Bfk是混合函数  

任意一条曲面可以用样条曲线函数的积来计算  
#### Bezier曲线和曲面：具体公式百度
特性分析：（1）曲线总是通过第一个和最后一个控制点   
         （2）曲线始点处的切线落在头两个控制点的连线上，终点处切线在后两个控制点连线上     
         （3）曲线落在控制点的凸壳内
设计技术：（1）封闭曲线，第一个和最后一个点重合
          （2）多个控制点位于同一位置可以更多加权，使曲线更接近某个控制点
三次bezier曲线
bezier曲面的数字描述由bezier基函数作笛卡尔积而得

## 规则形体构造
实体模型的三类表示方式：1.边界表示 2.构造实体几何表示 3.空间分割表示
### 构造实体几何法
CSG 集合运算的实现过程可以由一颗二叉树来描述 
根节点是csg对象，非终端节点是操作（平移，并），叶子是小对象（圆，位移距离）  
光线投射算法：从显示屏幕（投影平面的）每一个像素位置发射一根光线，求出射线与距离投影平面最近的可见表面的交点和交点处的表面矢量，  
再根据光照模型算出表面可见点的色彩和亮度，生成实体的光栅图形
### 空间位置分割：将空间分割成若干等大的立方体
八叉树：又称分层树结构，它对空间进行适应性划分，采用具有层次结构的八叉树来表示实体
也可以做交、并、差等运算
松散八叉树思想：一个多边形物体穿越了边界，可以把每个长方体的大小选中比较宽松，使物体完全在某一个长方体内  
二叉空间分割：每次将一实体用任一位置和任一方向的平面分为两部分
轴对齐的bsp树：将场景包围在一个轴对齐盒子里，然后递归的分割盒子
多边形对齐的bsp树：1.在根节点处，选择一个多边形，用这个多边形所在的平面将剩余多边形分为两组  
                  2.以递归的方式将所有多边形放入对应的bsp树中  
多边形bsp树应用：1.深度测试 轴对齐只能对应粗排序，多边形对齐对应相对视点的排序，可以与画家算法配合  
 2.相交测试 3.碰撞检测
### 分型几何：
1.不规则 2.在不同尺度上，图形的规则性又是相同的，例如雪花和山 
形状语法：给定一组产生式规则，形状设计者可以在从给定初始物体到最终物体结构的每一次变换中应用不同的规则
### 粒子系统：
生成的两要素：粒子本身的造型和粒子的运动方式
一个单一的粒子通常有一个生命值常量，从生产开始缓慢减少，直至某个极限值
struct partical{position，speed，color，size，life——time}  
根据每一帧的时间差值deltatime，来计算剩余的生命和位置变化  
渲染过程：公告板技术：无论从哪个方向看，物体好似始终朝着你 e.g. npc的血条

# 投影、变化、裁剪
投影等矩阵复习查看csdn
## 裁剪
### cohen-sutherland方法：基于编码的裁剪方法  
基本思想：对线段分三种情况处理：完全可见、完全不可见、部分可见部分不可见  
实现：每个点，根据所在区域，赋予一个四位的二进制码D3D2D1D0  
1001   1000   1010  
0001   0000   0010      （1000是窗口）  
0101   0100   0110  
（1）若code1|code2=0，对直线段应简取之
（2）若code1&code2!=0,对直线段可简弃之
（3）若都不成立，则算出和窗口的交点，然后分段处理
### 中点裁剪法
仍然基于cohen-sutherland的区域编码思想，当直线段要划分的时候，简单地将线段一分为二，对两段重复上述测试处理  
本质是用二分法求线段与窗口的交点
### Liang-Barsky裁剪的思想
任意直线段用参数方程表示
## 多边形的裁剪
### sutherland-hodgeman多边形裁剪
沿着每条边根据窗口输出可见测顶点 
问题：凹多边形会出问题  解决方法：分成多个凸多边形，分别处理/或者分割完后，沿着任何一个裁剪窗口边界检查顶点表，使正确配对
### weiler-atherton算法步骤：
(1)由不可见侧到可见侧，则输出可见直线段  
(2)由可检测到不可见侧，则沿窗口顺时针检测窗口边，找到最近的一个交点，输出可见直线段和当前交点到另一交点之间窗口边界上的线段，然后返回处理的当前交点  
## 几何阶段的总结
1.观察坐标系是右手定则，屏幕坐标系是左手定则
2.PVM矩阵
position = projection * view * model *vec4(apos,1.0);

# 片元着色（颜色）
## Phong模型：简单光照明模型模拟物体表面对光的反射作用
光源为点光源，反射作用分为：环境光、漫反射、镜面反射
### 环境光：没有光源的地方，景物没有收到光源的直接照射，但表面仍有一定的亮度。  
这是因为光线在场景中经过复杂的传播之后，形成了弥漫于整个空间的光线，成为环境光。  
同一环境下的环境光光强分布均匀 Ie=Ia*Ka Ia环境光强度，Ka物体对环境光的反射系数   

### 漫反射：光源来自一个方向，反射光均匀地射向各个方向，与视点无关
由lambert余弦定理，Id = Ip * Kd * costheta, theta是L与N的夹角，0到pi/2,L是p指向光源矢量，N是物体表面在P点的法矢量  
若L和N格式化为单位向量后 Id = Ip * Kd * (L.N)
### 镜面反射：非理想的反射面，反射光和观察者有角度差距alpha，但仍能观察到
Is= Ip * Ks * cos^n(alpha) n是反射系数，反应光滑程度，越大越光滑    cosalpha = R.V R反射光，V观察者，都是单位向量
### 实现：
#### Blinn-Phong模型：近似处理 将R.V处理为H.N,其中H是L和v的平分线，这样计算更快，通过改变n来弥补误差  
如果有多个光源，则在p点上叠加计算(环境光不叠加)
实际上距离越远，亮度越低，生成一个f(d)=min(1,1/c0+c1d+c2d^2)作为漫反射和镜面反射的系数
根据RGB三个轨道分别计算
### 马赫带效应：出现类似马赛克样东西
处理方法：1.多边形细分 
         2.多边形内部各点颜色计算： Gouraud明暗处理:多边形内部各点颜色计算，对顶点颜色双线性插值
                                  Phong明暗处理：各点法矢量获得，对顶点法矢量双线性插值
           Phong明暗处理好于gouraud，但是计算量也大
## whitted光投射模型 = Phong模型+透射光强
I=环境光强+反射光强+漫反射光强+It * Kt + Ir * Kr  It是折射方向光强 Kt是透射系数   Ir来自别的物体的反射 Kr反射系数
## 光线追踪算法
### 定义：
追踪光线路径，然后模拟光线与虚拟对象相互作用的方式  
### 主要思想：
从视点向成像平面上的像素发射光线，找到与该光线相交的最近物体的交点  
1.如果该点处的表面是漫反射表面，则计算光源直接照射改点产生的颜色  
2.如果改点出表面是镜面或者折射面，则继续反射或折射方向跟踪另一条光线  
结束条件是直到光源，追踪的结束条件是逃逸出场景或递归到一定深度  
### 缺点：
1.表面属性单一：完全看不到折射光？完全没有镜面反射？ 2.不考虑漫反射，漫反射为结束条件  
改进方法：将一个表面认为是混合的，然后根据表面的材质属性继续采样一个方向  
新缺点：计算量很大  新改进：蒙特卡洛方法：通过概率理论，进行近似简化  --》路径追踪
### 路径追踪算法=光线追踪+蒙特卡洛方法

# 片元着色（纹理）
纹理：现实物体有各种表面细节，这些细节就叫纹理
类型： 颜色纹理：花纹，图案  几何纹理：物体表面的微观几何形状（法向量不同）
## 颜色纹理处理方法：预先定义纹理模式，当物体表面的可见点确定后（通过像素区和物体表面对应），以纹理模式的对应点参与光照模型进行计算，  
就可把纹理模式附到物体表面上，这种方法成为纹理映射  
纹理模式定义：图案纹理和函数纹理  
纹理空间：纹理定义在纹理空间上的函数，纹理空间通常是一个单位正方形区域  
纹理映射方法：1.对物体表面坐标进行u、v参数化    
             2.反求出参数u、v用物体表面坐标的表达  
             3.根据纹理空间定义的纹理(u、v)得到该处的纹理值，并用此值取代光照模型中的相应项，实现纹理映射  
立方体贴图：6个2d纹理，每个2d纹理是一个立方体的一个面  
## 几何纹理
给法向量一个微小的扰动，产生凹凸不平的效果
凹凸贴图，移位贴图（唯一一个使表面真的变得凹凸不平的方法）,法线贴图,视差贴图，浮雕贴图
### 法线贴图
现实中物体表面是凹凸不平的，我们可以让光照相信一个表面由很多微小（垂直于法线向量）平面所组成。  
这种每个fragment使用各自的法线，替代一个面上所有fragment使用同一个法线的技术叫做法线贴图  
height map的使用： 高度图储存的是RGB值  但其实对应了x,y,z方向  
#### 切线空间的引入：
多个不同朝向的平面需要根据某个平面法向量变换到全局中，例如一个立方体法线贴图  
每个平面都有一个自己的切线空间 T：切线 B：副切线 N：normal法线
TBN的计算：通过三个公面而且不是共线的P1、P2、P3分别计算TBN的方向量 TBN方向量构成TBN矩阵
## 阴影效果
### 基本思想：将视点移到光源位置  
用多边形区域排序消隐算法将多边形分为两大类：向光多边形和背光多边形  
向光多边形：从光源看过去可见的多边形；
背光多边形：从光源看过去是不可见的多边形，包括被其他面遮挡的多边形和反向面多边形  
向光多边形不在阴影区内，背光多边形在阴影区内。
### 再通过光照模型计算多边形的亮度
e.g. Phone模型
对于背光多边形，由于不能得到光源的直接照射，只有环境光对其光强有贡献，因此关闭漫反射和镜面反射  
对于向光多边形，正常进行光照计算  
### 阴影的计算方法
shadow mapping：一个物体之所以会在阴影之中，是由于在它和光源之间存在着遮蔽物，或者说遮蔽物离光源的距离比物体要近
shadow volumn：根据光源和遮蔽物的位置关系计算出场景中会产生阴影的区域，然后对所有物体进行检测，以确定会不会受到阴影的影响
#### shadow map详解
step1：以光源为视点，得到所有物体相对于光源的depth map（也就是shadow map），  
这幅图像中每个像素的值代表着离光源最近的fragment的深度值。由于只关注深度值，所以可以关闭光照计算  
step2：将视点恢复到原来的正常位置，渲染整个场景，对每个像素计算它和光源的距离，然后将这个值和depth map中相应的值进行比较，  
已确定这个像素点是不是在阴影中。然后根据比较的结果，对有阴影的片元和没阴影的片元进行分别的光照计算
阴影失真：表面shadow map凹凸不平导致阴影片元和光照片元交替出现  
解决方法：阴影偏移，这样片元就不会被错误的认为在表面之下了

# 片元操作
片元->模板测试—>深度测试->颜色混合->颜色缓冲区->帧缓存
## 缓存区
颜色缓存：缓存了每个像素点颜色值  
模板缓存：存储一个模板，可以设定模板为1才显示(mask)  
深度缓存：存储每个像素点的深度坐标，也就是z坐标  
累计缓存：和颜色缓存类似  
         用途：合成多幅图像，实现场景中“多重曝光”  
         方法：通过将图像渲染多次，对场景位置进行微小的、渐增的改变,然后累计结果
         e.g. 运动模糊
### 颜色混合
RGBA模型，当A不是1.0f 即颜色有一定的透明度时，可以进行颜色混合  
每个rgba轨道对应一个调和因子，相乘后将源图和目标图相加计算  
e.g. 1.累计缓存也是通过颜色混合来合并图像的  
     2.泛光效果，对图中高亮度光源提出来进行高斯模糊处理，然后颜色混合     
### gpu双重缓存
一般渲染结果储存到后置帧缓存中，然后再与前置帧缓存交换，这个前置帧缓存和显示设备直接关联
## 消隐和深度测试
消隐：决定场景中哪些物体的表面是可见的，哪些是被遮挡不可见的
正方面定义：右手定则N向量  
如果Vview.N>0，则为后向面，是不可见的
在片元着色之前做面剔除
### 深度缓冲器算法（Z-buffer算法）
1.初始化：将深度缓存和帧缓存中的所有单位(x,y)初始化：  
         深度缓存中各点值为Z的最大值1，帧缓存中各点值为背景色  
2.处理场景中每一条多边形，每次一个，计算多边形上的各点(x,y)的深度值Z  
若z<depthbuffer(x,y) 则depthbuffer(x,y)=z;取得该多边形表面的颜色值surfcolor(x,y) frameBuffer(x,y)=surfColor(x,y)  
### 深度排序算法，又叫画家算法
思想：画家画画的时候，总是先画背景，然后画较远处的场景，然后是近一点的物体，最后画最近的景物   
数据结构：1.多边形队列M：存储所有多边形  
         2.优先级队列N：深度排序得到的结果，按优先级存放所有多边形  
算法步骤：1.深度排序：将多边形按深度优先级进行排序，结果存入N中，距视点近的优先级高
         2.扫描转换：从队列N中逐个取出多边形进行绘制，其实就是从优先级低的多边形开始扫描转换
#### 深度排序细节
step1. 将场景中的所有多边形按Zmax由大到小的顺序存入一个先进先出队列中，记为M 同时初始胡空的队列N
step2. 如果M中多边形个数是1，则将M中的多边形直接加入到N中，同时将A从M中删除
step3.1 有多个多边形时候，从当前M取出多边形B，对A与B进行比较
      （a）如果对于M中任意B均有Zmax（B）<Zmin（A）,则说明A是M中所有多边形中深度最深的  
          它与其他多边形在深度方向上没有任何重叠，不会遮挡别的多边形,将A按先进先出原则放入N中（最后也是最先扫描转换）  
       (b) 判别多边形A和B在xoy平面上投影的包围盒有无重叠，若没有，则A、B在队列中的顺序无关紧要，将A先放入N中  
       (c) 假设A和B重叠平面是P，判断在P上B是否完全在A前面,即Zmin（A）>Zmax(BonP),则A先放入N  
       （d）A有部分在P之前，则判断B上平面A与B重叠平面是否完全在A之前 Zmin（AonP）>Zmax(BonP),则A先放入N  
step3.2 当A,B排序好了，继续处理其他的多边形 假设B被A遮挡，如果发现C被B遮挡，那么N中排序由BA变为CBA
Opengl中可以开启多边形剔除：glEnable(GL_CULL_FACE); glCullFace(mode);
深度测试是默认关闭的，如果需要打开：glEnable(Gl_DEPTH_TEST);

#游戏渲染技术
1.运动模糊：颜色混合  
2.泛光：颜色混合  
3.天空和：立方体贴图  
4.公告板技术：让四边形跟着视角方向旋转的技术 可以完成很多特别的效果：烟雾，火焰，能量盾，云彩  
             虽然有更真实的技术可以实现，但是公告板技术实现这些效果所使用的系统资源极低
5.延迟渲染
正向渲染：先光照计算，后深度测试  e.g. n个物体，m个光源，共计算NXM次
延迟渲染：先深度测试，后光照计算  只对可见的物体进行计算，远小于nxm次
用到一个G-buffer：几何缓冲区，勇于存储每个像素对应的位置，法线和漫反射颜色以及其他有用的材质参数
6.层次细节LOD
又名多细节层次，根据物体模型在显示环境中所处的位置和重要度，根据距离动态的渲染不同细节模型，  
相当于空间换时间的方式获得高效率的渲染运算，最常用的游戏优化技术
