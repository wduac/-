三维转换之前的知识点:
https://blog.csdn.net/qq_36459481/article/details/87515998

# 图元扫描算法
## 1 直线的画法  链接：https://www.cnblogs.com/mangoyuan/p/6576145.html
DDA把算法效率提高到每步只做一个加法  
中点画线算法进一步将效率提高到每一步只做一个整数加法  （）
bresenham整数运算，速度快;精度高;乘2可用移位运算，适于硬件实现
### 1.1 数值微分(Digital Differential Analyzer)算法

已知过端点 P0(x0, y0)，P1(x1, y1) 的直线段 L(P0, P1)；直线斜率为 k = (y1 - y0) / (x1 - x0)。<br/>	
于是 yi+1 = kxi+1 + b。<br/>	
于是，x每增加1，y就增加k。画点的时候还需要判断 int(y+0.5) 向下取整。<br/>	

### 1.2 中点画线法
### 1.3 Bresenham画线算法

## 2 圆弧扫描方法
### 2.1 和中心点算法类似，计算d 然后判断上下点取值  
### 2.2 bresenham算法

## 3 椭圆扫描算法(类似增量算法)
 
## 4 多边形
表示多边形：不只需要边界像素集，还需要内部点集
### x扫描线算法:
#### 原理
1.得到多边形占有的最大扫描边数，得到多边形顶点的最大和最小值  
2.从y=ymin到y=ymax，每次用一条扫描线进行填充  
3.对一条扫描线填充的过程可以分为四个步骤：a.求交  b.排序  c.交点配对  d.区间填色  
问题：1.两条边交于同一点，算几个顶点  答：交点个数=构成这个顶点的两条边位于扫描线上方的条数  
     2.每个像素点看成一个圆，四等分，然后左闭右开，下闭上开  
可以改进的地方：1.对于某一条扫描线,不需要与所有的边相交，只用找到有效边
               2.可以用增量计算的方法算出交点(从上到下扫描，y每一次变化1)
               3.不用每次都排序，当边变成无效边的时候删除，重新排序的时机：有新边的加入  
#### 算法实现  
边表：从y=1 到 y=10共十个桶，把每次出现的边放入桶中      
新边：x ymax 1/k next（每条新边对应一个结点）    新边排序原则：交点递增、交点相同，增量递增  
为了实现 交点个数=构成这个顶点的两条边位于扫描线上方的条数 把新边的ymax减1，相当于这个ymax点没有与该新边的直线相交  
有效边表：存储有效边的表，每次x扫描一次，每个边的x就做增量计算，并且删除边和加入新边
优点：采用增量计算进行交点计算，且仅仅新边加入时候排序
缺点：桶表、链表的维护开销

### 边缘填充算法、栅栏填充算法和边标志算法
边标志算法：打标记，填充，初始是假，遇到标记点取反，真的时候填充  
优点：每个像素仅访问一次，避免了对帧缓存中大量元素的多次赋值，但仍需逐条扫描线地对帧缓存中的元素进行搜索和比较   
当用软件实现时候，和y向连贯性算法相当，但是硬件实现后速度提升很快  

## 5 区域填充
内界表现法和内点表现法  对应的边界填充(边界表示)和泛填充算法(内点表示)  
### 种子填充思想：先取任意内点为种子，开始填充
#### 边界填充:（已经有了边界点集合）
   4-连通边界算法：种子进栈  
   重复步骤：1. 栈顶像素出栈 2. 将出栈像素置成填充色 3.检查出栈像素的4连接点，若其中某个不是边界且未置色，则将该像素入栈  
#### 泛填充：
   前面步骤一样，第三步改为：若其中某个像素点是给定内部点的颜色且未置成新的填充色，则将该像素入栈  
#### 分析和改进
1.8连通边界算法不能填充4连接边界算法，因为会有点出边界，然后扩散出去  
2.8连接泛填充算法可以填充，因为外界的点没有内部点颜色，所以不会入栈，也就不会扩散出去  
3.每次种子只把水平部分相同的种子入栈，一行一行的来填充入栈，这样就不会有重复入栈的像素个数，提高了算法的效率  

## 6.线段的属性
通过频率插入一段空白，来变成虚线     像素模板：一段模板(包含直线和虚线)，需要根据线段角度来调整模板，不然空白可能有时很多，有时很小
线刷子：根据斜率，有垂直线刷子和水平线刷子   这样端点会不自然，一般会加个线帽，使更自然   但折现有时候会不自然
方刷子： 也分斜率  和先刷字相比：1.不需要改变方向 2.比实际线宽粗  3.自带一个帽子

## 7.走样
e.g. 微小物体的忽略，比如线条在两个像素点中间的时候，两边都不表示（根本原因是光栅化后，颜色变成离散量）
### 走样方法：
1. 提高分辨率
2. 过取样，或过滤波：高分辨率下取样计算，对几个像素属性进行平均，生成低分辨率下的像素属性 e.g.过取样例子：重叠过取样 假设显示分辨率是m x n，则将显示窗口分为(2m+1)x(2n+1)个子像素 最后加权除以9  
3. 前滤波，区域取样：根据图形在像素点上的覆盖率来算：根据斜率和起点计算直线段和像素相交面积   
e.g. 1.将屏幕像素分割成n个更小的子像素  2.计算中心落在直线段内的子像素的个数m   3. m/n为线段与像素相交区域面积的近似值
e.g. 加权区域取样 扩展：高斯滤波 
特点： a.理想直线的像素将被分配更多的灰度值  
       b. 相邻两个像素的滤波器相交，有利于缩小直线条上相邻像素的灰度查


             
