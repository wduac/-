questiosn：
1.什么是右值引用，什么是右值，右值如何变左值

csdn:https://www.cnblogs.com/likaiming/p/9045642.html
左值：一开始是可以获得地址的变量  右值：不能获得地址的对象（常数，函数返回值，lambda表达式). 虽然不能获得地址，但并不是不能改变大小，例如可以用右值引用来改变大小

e.g.左值                                     e.g.右值
int i = 10;                                  int && iii = i;
int & ii = I;

c++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置
临时变量根本上来说就是一个没有名字的变量而已。它的生命周期和函数栈帧是一致的。也可以说临时变量和它的引用具有相同的生命周期。

int & i = 10; //iS NOT ALLOWED
原因很明显，左边是一个左值引用，而右边是一个右值，无法将左值引用绑定到一个右值上。但是如果是一个const的左值引用，是可以绑定到右值上的。即如下写法是符合语法规范的：
const int & i = 10;

能将右值引用赋值给左值引用，该左值引用绑定到右值引用指向的对象

MOVE:
根据右值引用的语法规则可知，不能将右值引用绑定到一个左值上，c++11引入右值引用，并且提供了move函数，用来获得绑定到左值上的右值引用，此函数定义在头文件utility中

e.g.1
template<class T> void f1(T&) {}
f1(i)           //i是一个int，模板参数类型T是int
f1(ci)         //ci是一个const int，模板参数T是const int
fl(5)           //错误：传递给一个&参数的实参必须是一个左值

e.g.2
template<class T> void f2(const T&) {}
f2(i)           //i是一个int，模板参数类型T是int，因为非const可以转化为const
f2(ci)         //ci是一个const int，模板参数T是int
f2(5)          //看前面，const的引用可以绑定右值，T是int


2. 智能指针，智能指针是否是线程安全的（部分线程安全）,shared_ptr实现原理
https://blog.csdn.net/flowing_wind/article/details/81301001

动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。
为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。
标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。
标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。
shared_ptr<string> p1;
shared_ptr<int> p3 = make_shared<int>(42);

我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数，无论何时我们拷贝一个shared_ptr，计数器都会递增。
当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减，一旦一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象。

auto r = make_shared<int>(42);//r指向的int只有一个引用者
r=q;//给r赋值，令它指向另一个地址
    //递增q指向的对象的引用计数
    //递减r原来指向的对象的引用计数
    //r原来指向的对象已没有引用者，会自动释放
    
const int *pci = new const int(1024);
//分配并初始化一个const int
const string *pcs = new const string;
//分配并默认初始化一个const的空string
类似其他任何const对象，一个动态分配的const对象必须进行初始化

shared_ptr<int> p1 = new int(1024);//错误：必须使用直接初始化形式
shared_ptr<int> p2(new int(1024));//正确：使用了直接初始化形式

与赋值类似，reset会更新引用计数，如果需要的话，会释放p的对象。reset成员经常和unique一起使用，来控制多个shared_ptr共享的对象。
在改变底层对象之前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝：
if(!p.unique())
p.reset(new string(*p));//我们不是唯一用户，分配新的拷贝
*p+=newVal;//现在我们知道自己是唯一的用户，可以改变对象的值

虽然我们不能拷贝或者赋值unique_ptr，但是可以通过调用release或reset将指针所有权从一个（非const）unique_ptr转移给另一个unique
//将所有权从p1（指向string Stegosaurus）转移给p2
unique_ptr<string> p2(p1.release());//release将p1置为空
unique_ptr<string>p3(new string("Trex"));
//将所有权从p3转移到p2
p2.reset(p3.release());//reset释放了p2原来指向的内存

不能拷贝unique_ptr有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr.最常见的例子是从函数返回一个unique_ptr
unique_ptr<int> clone(int p)
{
    //正确：从int*创建一个unique_ptr<int>
    return unique_ptr<int>(new int(p));
}

还可以返回一个局部对象的拷贝：
unique_ptr<int> clone(int p)
{
    unique_ptr<int> ret(new int(p));
    return ret;
}

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。
一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。
由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock，此函数检查weak_ptr指向的对象是否存在。如果存在，lock返回一个指向共享对象的shared_ptr,如果不存在，lock将返回一个空指针

shared-ptr的线程安全性！！
https://www.cnblogs.com/gqtcgq/p/7492772.html
shared_ptr继承了下面的模板类，用它来管理引用计数。其中有两个变量一个表示shared_ptr的引用数，另外一个表示weak_ptr的引用数，
我们知道weak_ptr不会增加只能指针的引用数也就是说不持有对象，他的使用必须通过lock方法获取它指向的shared_ptr才能使用


Shared_ptr底层实现！！
https://blog.csdn.net/liyazhen2011/article/details/103636202

shared_ptr的构造函数中会开辟新的引用计数的资源。
shared_ptr的拷贝构造函数没有开辟新的引用计数的资源，只是引用计数加1。
智能指针的引用计数在手段上使用了atomic原子操作，只要在shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了
Q：首先原子操作是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的，但是这能真正的保证shared_ptr指针的线程安全问题吗？
A：首先智能指针有两个变量，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象， 当智能指针发生拷贝的时候，标准哭的实现是县拷贝智能指针，
再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子的，隐患就出现在这里
在赋值的过程中，改变了shard_ptr指向的对象的内容，甚至不只是修改了对象这么简单，上面的情景直接把智能指针指向的对象给换了。这中情况不用想肯定会出问题。
如果你能保证不会有多个线程同时修改或替换指针指向的对象，不用加锁是完全没有问题的，或者说指针指向的对象本身已经是线程安全（包括多线程下的读写安全和构造析构安全）


int *p = new int;       
shared_ptr<int> ptr1(p);
shared_ptr<int> ptr2(p);
//两次打印都是1，析构两次，出错
原因：ptr1(p) 和 ptr2(p)都调用了shared_ptr的构造函数，它们管理同一个资源，但是重新开辟了引用计数的资源。所以引用计数都为1。析构函数会被调用两次，所以程序出错。

int *p = new int;       
    shared_ptr<int> ptr1(p);
    shared_ptr<int> ptr2(ptr1);
    //两次打印都是2，析构一次，正确
原因：ptr1(p) 调用构造函数，ptr2(ptr1)调用拷贝构造函数（没有开辟新的引用计数的资源，只是引用计数加1）。析构函数会被调用一次，所以程序正确。

3.宏和内联函数的区别
https://blog.csdn.net/bit666888/article/details/81182975

以 inline 修饰的函数叫做内联函数。
内联函数在调用时不是像一般函数那样要转去执行被调用函数的函数体，执行完成后在转回调用函数中，执行其后的语句；
而是在调用处用内联函数体的代码来替换，这样没有函数压栈，将会节省调用的开销，提高运行效率。

用 inline 来定义内联函数，但任何在类的说明部分定义的函数都会被自动的认为是内联函数。
内联函数必须是和函数体声明在一起才有效。
// 该类中声明了3个内联函数，在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有关键字inline
nline是一种以空间换时间的做法，省去调用函数的开销。使用内联函数可以节省运行时间，但却增加了目标程序的长度。所以代码很长或者有循环、递归的函数不适宜使用内联函数，
就算用了编译器也会放弃内联方式，而采用像调用普通函数的方式去调用它

宏有什么缺点？
a.宏不能访问对象的私有成员
b.宏的定义很容易产生二义性

内联函数和宏的区别在于：宏是由预处理器对宏进行替换的，而内联函数是通过编译器控制实现的。而且内联函数是真正的函数，只是在需要用到的时候内联函数像宏一样的展开，
所以取消了函数的参数压栈，减少了调用的开销。所以可以像调用函数一样来调用内联函数，而不必担心会产生像宏出现的问题。

1. 在C++中强制建议使用const来代替宏常量，使用内联函数来代替宏函数。
2. const和内联函数在进行编译时不仅进行替换，而且还会进行参数类型检测，提高了程序的安全性。
3. 内联函数可以是普通函数，也可以是类的成员函数；函数式宏不能作为类的成员函数。

define宏定义和const常变量区别：

1.define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存。const定义的常量，在程序运行时在常量表中，系统为它分配内存。

2.define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。const定义的常量，在编译时进行严格的类型检验，可以避免出错。

3.define定义表达式时要注意“边缘效应”，例如如下定义：
#define N 2+3 //我们预想的N值是5，我们这样使用N，int a = N/2; //我们预想的a的值是2，可实际上a的值是3


4. 析构函数一定要设置为虚函数吗，为什么

虚函数的目的就是通知系统在函数调用时能够自动识别对应的类对象类型，从而能够根据指针所指类型调用对应的类对象，实现函数调用时的多态性。
对于析构函数而言，同样适用于上述规则。如果析构函数不是虚函数，那么在调用该函数时（对象被删除时）则只会调用当前对象对应的类的析构函数，这对于直接定义的对象是没有什么影响的，
但是对于使用基类指向派生类的指针而言，因为基类指针实际上是基类类型，所以析构时自然只会调用基类的析构函数，这就可能产生内存泄漏（因为派生类的析构函数不被调用）。
所以如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数指定为虚函数，如此才能确保NEW出来的对象被正确的DELETE

5.多态有几种实现机制
https://www.cnblogs.com/Allen-rg/p/6927129.html
静态多态：重载  是在编译的时候，就确定调用函数的类型。

动态多态：覆盖，虚函数实现  
在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。
虚函数实现原理：虚函数表和虚函数指针。
纯虚函数： virtual int fun() = 0
注意分辨：隐藏，重载，覆盖

6.面向对象三大特性
封装，继承，多态

7. Class和struct的区别
a.字面上的区别
b.默认成员权限区别 struct的成员默认权限是public，而class的成员默认权限是private
c.struct的默认继承方式为public，而class的默认继承为private.注意：在C语言中struct不可以继承，虽然我们知道在C++中struct可以继承，但在实际使用中，在不需要继承的场合我们使用struct，
而在需要继承的场合使用class，这样更贴近其字面意思，使程序有更好的可读性。
d.用于定义模板参数  模板为C++语言新增特性，C语言没有，只有class可用于定义参数，而struct不可以

8. 什么是大端小端，什么是网络字节序和主机字节序
https://www.cnblogs.com/MYSQLZOUQI/p/5596690.html
大端：字节存储顺序和字节增长顺序相反   小端：相同
主机字节序就是自己电脑上字节存储顺序
TCP/IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序
这么常用的操作，BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；
从网络字节序到主机字节序的转换函数：ntohs、ntohl。当然，有了上面的理论基础，也可以编写自己的转换函数

9.虚函数表是所有类共用一个吗
不是。 但一个类所有的对象共用一个

10. 指针和引用的区别
(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已
(2)引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。
(3)可以有const指针，但是没有const引用；
(4)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
(5)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
(6)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
(7)”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；
(8)指针和引用的自增(++)运算意义不一样；
(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；
(10)函数传递的时候，指针其实也是值传递，只是复制的指针p和原来p指向同一个地方   但引用传递就不一样了，所以引用传递节约时间和空间

11.const关键字
const定义的变量它的值是不允许改变的
int * const p2;//const修饰的是指针变量
const int *p1; 修饰的int （int const *p1是一样的）

12.explicit关键字
(a).explicit 关键字只能用于类内部的构造函数声明上。
(b)explicit 关键字作用于单个参数的构造函数。
(c)在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换。显示类型转换带()

13. malloc/free 和 new/delete区别
1.含义：malloc/free是标准库，而new/delete是c++操作符，它调用的是操作运算符重载operator new（）和operator delete()
2.使用:
int*p2=(int*)malloc(sizeof(int)*4);
（1）malloc开辟空间类型大小需手动计算，new是由编译器自己计算；
（2）malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针；
（3）malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；
（4）无论释放几个空间大小，free只传递指针，多个对象时delete需加[]
3.malloc/free为函数只是开辟空间并释放，new/delete则不仅会开辟空间，并调用构造函数和析构函数进行初始化和清理，如下为new/delete、new[]/delete[]实现机制
new[]的时候在开辟大小会多开辟四个字节，用于存放对象的个数，在返回地址时则会向后偏移4个字节，而在delete时则会查看内存上对象个数，
从而根据个数count确定调用几次析构函数，从而完全清理所有对象占用内存。
4.new/delete底层是基于malloc/free来实现的，而malloc/free不能基于new/delete实现；
5.因为new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；
6.对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变
7.对于new/delete若内存分配失败，用户可以指定处理函数或重新制定分配器（new_handler(可以在此处进行扩展)），malloc/free用户是不可以处理的。
8.最后一点对于new/delete与malloc/free申请内存位置说明，malloc我们知道它是在堆上分配内存的，但new其实不能说是在堆上，C++中，对new申请内存位置有一个抽象概念，
它为自由存储区，它可以在堆上，也可以在静态存储区上分配，这主要取决于operator new实现细节，取决与它在哪里为对象分配空间。所以有一些说法：new在堆上分配内存，可以说是不太精确的。

14.c++11 特性
https://www.nowcoder.com/tutorial/93/3e889999205d447daad9ec50a6f85d85
1.auto关键字
2.智能指针
3.右值引用
4.nullptr关键字 原来NULL是宏定义的，但是如果有重载就会出现问题
5.初始化列表来对列进行初始化
6.atomic原子操作用于多线程资源互斥操作（shared_ptr例子）
7.新增STL容器array以及tuple
8.可变参数模板
C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号”。
Template<class ... T>
void func(T ... args)
{
cout<<”num is”<<sizeof ...(args)<<endl;
}
省略号作用如下：
1）声明一个包含0到任意个模板参数的参数包
2）在模板定义得右边，可以将参数包展成一个个独立的参数

右值引用：C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。
纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。
！！https://blog.csdn.net/WizardtoH/article/details/80718605 好文
左值->右值：move函数
9.lambda表达式
https://www.cnblogs.com/DswCnblog/p/5629165.html

[capture list] (params list) mutable exception-> return type { function body }
e.g. sort(lbvec.begin(), lbvec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式
Lambda表达式的参数限制：
1.参数列表中不能有默认参数
2.不支持可变参数
3.所有参数必须有参数名

10. delete删除默认构造函数和默认拷贝函数
https://www.cnblogs.com/xiangtingshen/p/11005281.html

C++11中，当类中含有不能默认初始化的成员变量时，可以禁止默认构造函数的生成，
myClass()=delete;//表示删除默认构造函数
myClass()=default;//表示默认存在构造函数

当类中含有不能默认拷贝成员变量时，可以禁止默认构造函数的生成，
myClass(const myClass&)=delete;//表示删除默认拷贝构造函数，即不能进行默认拷贝
myClass & operatir=(const myClass&)=delete;//表示删除默认拷贝构造函数，即不能进行默认拷贝

//c++11 特性描述结束(待补充)

15. extern用法总结
a. extern修饰变量的申明
如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v. 前提：V本身是能被引用到的,多是全局变量。 如果是在函数里面声明extern int v;那么只能在函数里面使用

b.extern修饰函数声明
和修饰变量类似,可以在任何使用前的地方声明。对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数有什么区别呢？
extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。
这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的

c.extern修饰符可用于指示C或者C＋＋函数的调用规范
比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。
主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。

16.static用法
https://blog.csdn.net/wangbeibei23/article/details/89343705

a.所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。
利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突.static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.
b.static的第二个作用是保持变量内容的持久
存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见
PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。
e.g.
int fun(){
    static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a
    return count--; //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    
}
基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。
因此static 这个说明符在不同的地方所起的作用是不同的。
c.static的第三个作用是默认初始化为0
其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。
d.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）
在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：
(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。
(2)不能将静态成员函数定义为虚函数。
(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。
(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。
(6)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）
(7)静态成员初始化与一般数据成员初始化不同:
初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
初始化时不加该成员的访问权限控制符private，public等；
初始化时使用作用域运算符来标明它所属类；
所以我们得出静态数据成员初始化的格式：
<数据类型><类名>::<静态数据成员名>=<值>
(8)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？
不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。
